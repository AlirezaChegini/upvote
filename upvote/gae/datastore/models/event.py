# Copyright 2017 Google Inc. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS-IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Models for storing execution events from the various platforms."""

import logging

from google.appengine.ext import ndb
from google.appengine.ext.ndb import polymodel

from upvote.gae.datastore.models import mixin
from upvote.shared import constants


class Event(mixin.Base, polymodel.PolyModel):
  """Blockable Event.

  key = Key(User, user_email) -> Key(Host, host_id) ->
      Key(..., Blockable, hash) -> Key(Event, '1')
  NOTE: The Blockable key may be of any length (e.g. for Bundles).
  NOTE: The Event id is always '1'.

  Attributes:
    blockable_key: key, key to the blockable associated with this event.
    cert_key: key, key to the cert associated with this event.
    host_id: str, unique ID for the host on which this event occurred.
    file_name: str, filename of the blockable on last block.
    file_path: str, path of the blockable on last block.
    publisher: str, publisher of this file.
    version: str, version number of this file.
    executing_user: str, user who executed the binary (may be a system user).
    event_type: str, reason this event was initially created.
    recorded_dt: datetime, when this event was received by the server.
    first_blocked_dt: datetime, time of the first block.
    last_blocked_dt: datetime, time of the last block.
    count: int, the number of times a given event has occurred.
  """
  blockable_key = ndb.KeyProperty()
  cert_key = ndb.KeyProperty()
  file_name = ndb.StringProperty()
  file_path = ndb.StringProperty()
  publisher = ndb.StringProperty()
  version = ndb.StringProperty()

  host_id = ndb.StringProperty()
  executing_user = ndb.StringProperty()
  event_type = ndb.StringProperty(
      choices=constants.EVENT_TYPE.SET_ALL, required=True)

  recorded_dt = ndb.DateTimeProperty(auto_now_add=True)
  first_blocked_dt = ndb.DateTimeProperty()
  last_blocked_dt = ndb.DateTimeProperty()
  count = ndb.IntegerProperty(default=1)

  @property
  def run_by_local_admin(self):
    """Whether the Event was generated by the platform's admin user.

    Due to the platform-specific nature of "admin user," this property should be
    overridden by each platform's derivative models.

    Returns:
      bool, See method description.
    """
    return False

  @property
  def user_key(self):
    if not self.key:
      return None
    return ndb.Key(flat=self.key.pairs()[0])

  def _DedupeMoreRecentEvent(self, more_recent_event):
    """Updates if the related Event is more recent than the current one."""
    self.last_blocked_dt = more_recent_event.last_blocked_dt
    self.file_name = more_recent_event.file_name
    self.file_path = more_recent_event.file_path
    self.executing_user = more_recent_event.executing_user
    self.event_type = more_recent_event.event_type

  def _DedupeEarlierEvent(self, earlier_event):
    """Updates if the related Event occurred earlier than the current one."""
    self.first_blocked_dt = earlier_event.first_blocked_dt

  def Dedupe(self, related_event):
    """Updates the current Event state with another, related Event."""
    self.count += related_event.count or 1

    # related_event registered an Event earlier than the earliest recorded date
    if self.first_blocked_dt > related_event.first_blocked_dt:
      self._DedupeEarlierEvent(related_event)

    # related_event registered an Event more recently than the most recent
    # recorded date
    if self.last_blocked_dt < related_event.last_blocked_dt:
      self._DedupeMoreRecentEvent(related_event)

  @classmethod
  def DedupeMultiple(cls, events):
    """Dedupes an iterable of new-style Events.

    Args:
      events: An iterable of new-style Event entities to be deduped.

    Returns:
      A list of deduped Events.
    """
    distinct_events = {}
    for event in events:
      duped_event = distinct_events.get(event.key)
      if duped_event:
        duped_event.Dedupe(event)
      else:
        distinct_events[event.key] = event
    return distinct_events.values()

  def to_dict(self, include=None, exclude=None):  # pylint: disable=g-bad-name
    result = super(Event, self).to_dict(include=include, exclude=exclude)
    result['blockable_id'] = self.blockable_key.id()
    return result


class Bit9Event(mixin.Bit9, Event):
  """An event from Bit9.

  Attributes:
    description: str, Description.
    bit9_id: int, The largest Bit9 database ID associated with this event.
  """
  description = ndb.StringProperty()
  bit9_id = ndb.IntegerProperty(default=0)

  @property
  def run_by_local_admin(self):
    return self.executing_user == constants.LOCAL_ADMIN.WINDOWS

  def _DedupeMoreRecentEvent(self, more_recent_event):
    """Updates if the related Event is more recent than the current one."""
    if self.bit9_id > more_recent_event.bit9_id:
      logging.warning(
          'Database ID out-of-order with respect to event timestamp: '
          '(id=%s, dt=%s) occurred earlier than (id=%s, dt=%s)', self.bit9_id,
          self.last_blocked_dt, more_recent_event.bit9_id,
          more_recent_event.last_blocked_dt)

    super(Bit9Event, self)._DedupeMoreRecentEvent(more_recent_event)

  def Dedupe(self, related_event):
    """See base class."""
    super(Bit9Event, self).Dedupe(related_event)

    # We only care about the most recent event with respect to its ID in Bit9.
    self.bit9_id = max(self.bit9_id, related_event.bit9_id)


class QuarantineMetadata(ndb.Model):
  """Metadata provided by macOS File Quarantine.

  Attributes:
    data_url: str, the URL the file was downloaded from
    referer_url: str, the referer of the above URL
    downloaded_dt: datetime, when the file was downloaded
    agent_bundle_id: str, the program that downloaded the file
  """
  data_url = ndb.StringProperty(indexed=False)
  referer_url = ndb.StringProperty(indexed=False)
  downloaded_dt = ndb.DateTimeProperty()
  agent_bundle_id = ndb.StringProperty()


class SantaEvent(mixin.Santa, Event):
  """An event from Santa.

  Attributes:
    bundle_key: ndb.Key, If present, the key of the bundle to which the
        associated Blockable belongs.
    quarantine: QuarantineMetadata, metadata detailing the provenance of the
        Blockable.
    event_type: str, the reason that the last block was generated
    bundle_path: str, path of the associated bundle on the last block.

    DEPRECATED
    cert_sha256: the SHA-256 of the cert this file was signed with
  """
  bundle_key = ndb.KeyProperty()
  quarantine = ndb.StructuredProperty(QuarantineMetadata)
  event_type = ndb.StringProperty(
      choices=constants.EVENT_TYPE.SET_ALL, required=True)
  bundle_path = ndb.StringProperty()

  # DEPRECATED
  cert_sha256 = ndb.StringProperty()

  @property
  def run_by_local_admin(self):
    return self.executing_user == constants.LOCAL_ADMIN.MACOS

  def _DedupeMoreRecentEvent(self, more_recent_event):
    """Updates if the related Event is more recent than the current one."""
    super(SantaEvent, self)._DedupeMoreRecentEvent(more_recent_event)

    self.bundle_path = more_recent_event.bundle_path
    # Keep the newest non-null quarantine information
    if more_recent_event.quarantine:
      self.quarantine = more_recent_event.quarantine

  def _DedupeEarlierEvent(self, earlier_event):
    """Updates if the related Event occurred earlier than the current one."""
    super(SantaEvent, self)._DedupeEarlierEvent(earlier_event)

    # If an older Event has quarantine information and this one does not, pull
    # in the older Event's data
    if not self.quarantine and earlier_event.quarantine:
      self.quarantine = earlier_event.quarantine
